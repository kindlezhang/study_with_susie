---
title: "Untitled"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r}
library(dplyr)
library(tidyverse)
library(survey)
```

```{r}
## read in the data
data = read.csv("data_file/example.csv")
dim(data)
```

1. recording and rerun weighting method
2. machine learning (probit bart, xgboost, super learner, etc.)
3. hw
4. replicate weight


```{r}
## gender - 1: male, 2: female
## age_grp - 2: [18,40), 3: [40,60), 4: [60,75), 5: >=75
## BMI_c - 1: <25, 2: [25, 30), 3: >=30    
## race - 1: Mexican American, 2: Other Hispanic, 3: Non-Hispanic White, 4: Non-Hispanic Black, 6:Non-Hispanic Asian, 7: Other Race, Including Multi-Racial
## citizen - 1: by birth or naturalization, 2: Not a citizen of the US 
## educ - 1: high school graduate or less, 2: some college or associate's degree, 3: Bachelor’s degree, 4: Advanced degree
## marital - 1: <= married 2: not married
## income_grp - 1: Under $20,000 2: $20,000 to 74,999 3:$75,000 to $99,999, 4: >=$100,000
## ALQ - 1: yes 2: no
## smoke - 1: every day; 2: some days; 3: not at all
## HBP - 1: yes, 2: no
summary(data)
```

```{r}
## transform categorical data into factor type
data = data %>% 
  mutate(
    strata = as.factor(strata),
    age_grp = as.factor(age_grp),
    gender = as.factor(gender),
    race = as.factor(race),
    citizen = as.factor(citizen),
    educ = as.factor(educ),
    marital = as.factor(marital),
    income_grp = as.factor(income_grp),
    ALQ = as.factor(ALQ),
    smoke = as.factor(smoke),
    diabetes = as.factor(diabetes),
    HBP = as.factor(HBP),
    BMI_c =as.factor(BMI_c)
  ) 
```

```{r}
## build a logistic regression model for response indicator
## BMI or BMI_c ?
logit_model = glm((!is.na(HbA1c)) ~
                  strata+age_grp+gender+race+citizen+educ+marital+income_grp+BMI+ALQ+smoke+HBP, 
                  data = data, family = binomial(link = "logit"))
summary(logit_model)
```

# inverse propensity score

```{r}
## propensity score weighting (psw)
pw = predict(logit_model, newdata = data, type = "response")
data$WT_psw = 1 / pw
data$WT_psw[is.na(data$HbA1c)] = 0
summary(data$WT_psw[!is.na(data$HbA1c)])
```

```{r}
## Construct the new weight
data$adjW_psw = data$weight * data$WT_psw
summary(data$adjW_psw[!is.na(data$HbA1c)])
```

```{r}
summary(data$weight)
```

# stratification 

```{r}
pw_class = cut(pw, breaks=quantile(pw,probs=seq(0,1, by=0.2)), 
               include.lowest=TRUE, labels = c(1,2,3,4,5), dig.lab = 7)

## Check balance within each group. The mean should be similar in each class for missing and observed outcome
group_by(as.data.frame(list("pw" = pw, "pw_class" = pw_class, 
                            "missing" = is.na(data$HbA1c))), 
         pw_class, missing)  |>  summarise(n = length(pw), mean.ps = mean(pw))
```

```{r}
## Estimated unweighted response rate in each stratum
pw_rps = 
    group_by(as.data.frame(list("pw_class" = pw_class, "weight" = data$weight, "missing" = is.na(data$HbA1c))), pw_class) %>% 
  mutate(
    group_n_sum = length(weight),
    m = sum(1 - missing) / group_n_sum
    ) %>% 
  ungroup() %>% dplyr::select(m) %>% 
  unlist(use.names = FALSE)
data$WT_pss = 1 / pw_rps
head(data)
sort(unique(data$WT_pss))
```

```{r}
## Estimated weighted response rate in each stratum
pw_wrps = group_by(as.data.frame(list("pw_class" = pw_class, "weight" = data$weight, "missing" = is.na(data$HbA1c))), pw_class) %>% 
  mutate(
    group_n_sum = sum(weight),
    m = sum((1 - missing)*weight) / group_n_sum
    ) %>% 
  ungroup() %>% dplyr::select(m) %>% 
  unlist(use.names = FALSE)
data$WT_wpss = 1 / pw_wrps
head(data)
sort(unique(data$WT_wpss))
```

```{r}
## Construct the new weight using the unweighted response rate
data$adjW_pss = data$weight * data$WT_pss
head(data)
summary(data$adjW_pss[!is.na(data$HbA1c)])
summary(data$weight)
```

what‘s the difference between psw and pss?

# Create adjustment cells using CHAID algorithm

```{r}
## The following four packages need to be installed before CHAID can be installed.
#install.packages("mvtnorm")
#install.packages("libcoin")
#install.packages("inum")
#install.packages("partykit")
#install.packages("CHAID",repos="http://R-Forge.R-project.org")
library(CHAID)
set.seed(8123)
chaidobj <- chaid(factor(!is.na(data$HbA1c)) ~ strata+age_grp+gender+race+citizen+educ+marital+income_grp+ALQ+smoke+HBP+BMI_c,data = data)
print(chaidobj)
```

```{r}
plot(chaidobj)
classes <- predict(chaidobj)
group_by(as.data.frame(list("HbA1c"=data$HbA1c, "rclass" = attributes(classes)$names)), rclass) %>% 
    summarise(n = length(HbA1c), miss=sum(is.na(HbA1c)==TRUE))
```

```{r}
#### Calculate weight by using the unweighted response rate in each terminal node of the tree
chaid_pw = data.frame(data, rclass = attributes(classes)$names) %>% 
  group_by(rclass) %>% 
  mutate(
    m = sum(1 - is.na(HbA1c))/length(weight),
  ) %>% 
  ungroup() %>% dplyr::select(m) %>% unlist(use.names = FALSE)
data$WT_chaid = 1 / chaid_pw
head(data)
sort(unique(data$WT_chaid))
```

```{r}
## Construct the new weight
data$adjW_chaid = data$weight * data$WT_chaid
head(data)
summary(data$adjW_chaid[!is.na(data$HbA1c)])
```

# cal propensity score by uesing machine learning packages

## bart package probit

```{r}
library(BART)
```

```{r}
# transfer Y to binary response indicator
data$HbA1c_nonmissing = as.numeric(!is.na(data$HbA1c))

# delete rows with missing values in the covariates
bart_data = data[complete.cases(data[c("strata","age_grp","gender","race","citizen",
                                       "educ","marital","income_grp","BMI","ALQ","smoke","HBP")]), ]

y_train = bart_data$HbA1c_nonmissing
X_train = bart_data[, c("strata","age_grp","gender","race","citizen",
                        "educ","marital","income_grp","BMI","ALQ","smoke","HBP")]

# use Probit BART
fit_bart = pbart(x.train = X_train, y.train = y_train)
str(y_train)
str(X_train)
str(fit_bart)
fit_bart$prob.train.mean
```

```{r}
data$WT_probit = 1 / fit_bart$prob.train.mean
data$WT_probit[is.na(data$HbA1c)] = 0
summary(data$WT_probit[!is.na(data$HbA1c)])
```

```{r}
## Construct the new weight
data$adjW_probit = data$weight * data$WT_probit
summary(data$adjW_probit[!is.na(data$HbA1c)])
head(data)
```

## xgboost package

Gradient Boosting Machine

 gradient-boosted decision tree

```{r}
library(xgboost)

# Prepare data for xgboost
predictors = c("strata", "age_grp", "gender", "race", "citizen",
               "educ", "marital", "income_grp", "BMI", "ALQ", "smoke", "HBP")
model_data = data %>%
  select(all_of(c(predictors, "HbA1c_nonmissing"))) %>%
  na.omit()  

# Convert categorical variables to factors
y = model_data$HbA1c_nonmissing
X = model.matrix(~ . -1, data = model_data %>% select(-HbA1c_nonmissing))  


dtrain = xgb.DMatrix(data = X, label = y)
```

```{r}
# Train the XGBoost model
xgb_fit = xgboost(data = dtrain,
                  objective = "binary:logistic",
                  nrounds = 100,
                  max_depth = 3,
                  eta = 0.1,
                  verbose = 0)
```

```{r}
pred_probs = predict(xgb_fit, newdata = dtrain)
head(pred_probs)
pred_probs
```

```{r}
data$WT_xgboost = 1 / pred_probs
data$WT_xgboost[is.na(data$HbA1c)] = 0
summary(data$WT_xgboost[!is.na(data$HbA1c)])
```

```{r}
## Construct the new weight
data$adjW_xgboost = data$weight * data$WT_xgboost
summary(data$adjW_xgboost[!is.na(data$HbA1c)])
head(data)
```

## super learner package

```{r}
library(SuperLearner)
```

```{r}

```

# Weight trimming

```{r}
#### Trim the weight to 3 times of mean weight
data.complete = data[is.na(data$HbA1c)==FALSE,]
head(data.complete)
des_psw = svydesign(data=data.complete, ids=~1, strata=~strata, weights=~adjW_psw)
summary(weights(des_psw))
```

```{r}
summary(data$weight)
```

```{r}
sum(weights(des_psw))
```

```{r}
des_psw_trim = trimWeights(des_psw, upper = 3*mean(weights(des_psw)), strict = TRUE)
summary(weights(des_psw_trim))
```

```{r}
sum(weights(des_psw_trim))
```

# Post-stratification

```{r}
## post-stratification is useful when the sample is different from the population and we have the 
## population data of joint distribution of the auxiliary variables. To implement the post-stratification 
## method, we first download a data set from the Census of Bureau website, which contains the counts of joint 
## distribution of age, sex, education for U.S. population in 2017: 
## https://www.census.gov/data/tables/2017/demo/age-and-sex/2017-age-sex-composition.html

## read in the population data and create a data that can be used in the post-stratification. 
## All the covariates that are used in the post-stratification need to have the same definition of 
## categories between the survey data and the population data. 

library("readxl")
library(tidyverse)
pop_male = read_excel("./data_file/2017gender.xls", sheet = 1, range = "A9:F22", 
                      col_names = c("Age", "Less than high school", "High school graduate", 
                      "Some college or associate's degree", "Bachelor’s degree", "Advanced degree"))
pop_female = read_excel("./data_file/2017gender.xls", sheet = 1, range = "A25:F38", col_names = c("Age", 
                        "Less than high school", "High school graduate", 
                        "Some college or associate's degree", 
                        "Bachelor’s degree", "Advanced degree"))
pop_male = mutate(pop_male, gender = "Male")
pop_female = mutate(pop_female, gender = "Female")
head(pop_female)
```

```{r}
pop = bind_rows(pop_male, pop_female) %>% 
    pivot_longer(
    cols = c("Less than high school", "High school graduate", "Some college or associate's degree",  
             "Bachelor’s degree", "Advanced degree"),
    names_to = "educ",
    values_to = "Freq"
  ) %>% 
  mutate(
    educ = if_else(educ == "Less than high school" | educ == "High school graduate", 
                   "High school graduate or less", educ),
    age = if_else(Age == ".18 to 24 years" | Age == ".25 to 29 years" | Age == ".30 to 34 years" | 
                    Age == ".35 to 39 years", "18 to 39 years", Age),
    age = if_else(Age == ".40 to 44 years" | Age == ".45 to 49 years" | Age == ".50 to 54 years" | 
                    Age == ".55 to 59 years", "40 to 59 years", age),
    age = if_else(Age == ".60 to 64 years" | Age == ".65 to 69 years" | Age == ".70 to 74 years", 
                  "60 to 74 years", age),
    age = if_else(Age == ".75 to 79 years" | Age == ".80 to 84 years" | Age == ".85 years and over", 
                  "75 years and above", age),
    age_grp = age
  ) %>% 
  mutate(
    gender = factor(gender, levels = c("Male", "Female")),
    age_grp = factor(age_grp, levels = c("less than 18 years", "18 to 39 years", "40 to 59 years", 
                                         "60 to 74 years", "75 years and above")),
    educ = factor(educ, levels = c("High school graduate or less", "Some college or associate's degree",
                                   "Bachelor’s degree", "Advanced degree"))
  ) %>% 
  dplyr::select(-Age, -age, gender, age_grp, educ, Freq)
  
head(pop)
```

```{r}
##### transform population data into the same format as survey data
pop.trans = pop %>% 
  mutate(
    gender = as.factor(as.integer(gender)),
    age_grp = factor(as.integer(age_grp), levels = seq(1, 5)),
    educ = as.factor(as.integer(educ))
  )

pop.trans$Freq=pop.trans$Freq*1000

pop.sum = group_by(as.data.frame(list("Freq"=pop.trans$Freq, "gender" = pop.trans$gender, "educ"=pop.trans$educ, "age_grp"=pop.trans$age_grp)), educ, age_grp, gender) %>% 
    summarise(Freq = sum(Freq))
sum(pop.sum$Freq)
# write.csv(pop.sum, file = "data_file/population.csv", row.names = FALSE)
```

```{r}
#### poststratification on the top of the weights created using the propensity score weighting method
des_psw_p = postStratify(des_psw_trim, ~educ + age_grp + gender, pop.sum)
summary(weights(des_psw_p))
```

```{r}
sum(weights(des_psw_p))
```

# Raking

```{r}
## Raking is commonly used in surveys to correct for selection bias. Different from post-stratification 
## that requires the joint distribution of covariates in the population, raking only requires the marginal 
## distribution of these covariates to be known. 

### marginal distributions with transformed population data
pop.gender = pop.trans %>% group_by(gender) %>% summarise(Freq = sum(Freq))
pop.age_grp = pop.trans %>% group_by(age_grp) %>% summarise(Freq = sum(Freq))
pop.educ = pop.trans %>% group_by(educ) %>% summarise(Freq = sum(Freq))

#### raking on the top of the weights created using the propensity score stratification method
des_psw_r = rake(des_psw_trim, list(~gender,~age_grp,~educ), list(pop.gender, pop.age_grp, pop.educ))
summary(weights(des_psw_r))
```

```{r}
sum(weights(des_psw_r))
```